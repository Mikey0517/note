import { v4 } from 'uuid';let socketIdDictionary = {};let socketInfo = new Map();let rooms = {};module.exports = wss => {	wss.on( 'connection', ( ws, req ) => {		let socketId = v4();		console.log( `socketId: ${ socketId }连接成功`  )		socketIdDictionary[ socketId ] = ws;		socketInfo.set( ws, getSocketInfo( socketId, req ) );		ws.on( 'message', handleDealMassage.bind( this, socketId ) );		ws.on( 'close', handleClose.bind( this, socketId ) );		Object.keys( socketIdDictionary ).map( id => {			sendOnLineList( id );		} )	} );}const sendOnLineList = socketId => {	let data = [];	for ( let value of socketInfo.values() ) {		value.isUser = value.id === socketId;		data[ value.isUser ? 'unshift' : 'push' ]( value );	}	socketIdDictionary[ socketId ].send( JSON.stringify( {		type: 'onLineIpList',		data	} ) );}const getParam = url => {	let list = url.split( '?' )[ 1 ].split( '&' );	let param = {};	for ( let i = 0; i < list.length; i++ ) {		let item = list[ i ].split( '=' );		param[ item[ 0 ] ] = item[ 1 ];	}	return param;}const getSocketInfo = ( socketId, req ) => {	console.log( req.socket.remoteAddress )	let ip = req.headers[ 'x-forwarded-for' ] === void 0 ? req.socket.remoteAddress.split( ':' )[ 3 ] : req.headers[ 'x-forwarded-for' ].split( /\s*,\s*/ )[ 0 ];	return {		id: socketId,		ip,	};}const handleClose = socketId => {	console.log( `${ socketId }: 退出` )	let ws = socketIdDictionary[ socketId ];	socketInfo.delete( ws );	delete socketIdDictionary[ socketId ];	Object.keys( socketIdDictionary ).map( id => {		sendOnLineList( id );	} )}const handleDealMassage = ( socketId, msg ) => {	const { type, data } = JSON.parse( msg );	if ( type.includes( 'backgammon' ) ) {		dealBackgammonMessage( socketId, JSON.parse( msg ) );	} else if ( type.includes( 'chat' ) ) {		dealChatMessage( socketId, JSON.parse( msg ) );	} else {		switch ( type ) {			case "close":				handleClose( socketId );				break;			case "launch":				handleLaunch( socketId, data );				break;			case "reply":				handleReply( socketId, data );				break;			case "quit-room":				sendRoomMessage( socketId, JSON.parse( msg ), 1 );		}	}}/** * 创建对战房间,并发送邀请 * */const handleLaunch = ( socketId, rivalSocketId ) => {	const roomId = v4();	// 绑定房间和用户	addRoomInfo( socketId, roomId, { type: 'rival' } );	// 给对手发送邀请消息	socketIdDictionary[ rivalSocketId ].send( JSON.stringify( {		type: 'invite',		data: {			roomId,			rivalIp: socketInfo.get( socketIdDictionary[ socketId ] ).ip		}	} ) )}/** * 回复邀请，同意或者拒绝 * */const handleReply = ( socketId, data ) => {	const { type, roomId } = data;	if ( type === 'accept' ) {		// 同意邀请		// 绑定房间和用户		addRoomInfo( socketId, roomId, { type: 'rival' } );		const room = rooms[ roomId ];		for ( let i = 0; i < room.length; i++ ) {			socketIdDictionary[ room[ i ] ].send( JSON.stringify( {				type: 'open-room',				data: {					roomId,					firstMove: socketId !== room[ i ],					ip: socketInfo.get( socketIdDictionary[ room[ i ] ] ).ip				}			} ) )		}	} else {		// 拒绝邀请		if ( rooms[ roomId ] && rooms[ roomId ][ 0 ] ) {			// 向对方发送拒绝消息			socketIdDictionary[ rooms[ roomId ][ 0 ] ].send( JSON.stringify( {				type,			} ) )		}		// 删除房间		deleteRoomInfo( roomId );	}}/** * 绑定房间和用户 * */const addRoomInfo = ( socketId, roomId, roomInfo ) => {	const ws = socketIdDictionary[ socketId ];	const info = socketInfo.get( ws );	if ( rooms[ roomId ] === void 0 ) rooms[ roomId ] = [];	if ( !rooms[ roomId ].includes( socketId ) ) rooms[ roomId ].push( socketId );	socketInfo.set( ws, Object.assign( {}, info, { roomInfo } ) )}/** * 获取房间信息 * */const getRoomUserInfo = ( socketId ) => {	const ws = socketIdDictionary[ socketId ];	const info = socketInfo.get( ws );	return info.roomInfo;}/** * 删除房间信息 * */const deleteRoomInfo = ( roomId ) => {	const room = rooms[ roomId ];	if ( room === void 0 ) {		console.log( "房间已被删除或不存在" )		return;	}	for ( let i = 0; i < room.length; i++ ) {		const ws = socketIdDictionary[ room[ i ] ];		let info = Object.assign( {}, socketInfo.get( ws ) );		if ( info.roomInfo !== void 0 ) delete info.roomInfo;		socketInfo.set( ws, info );	}	console.log( `删除房间：${ roomId }` );	delete rooms[ roomId ];}/** * 发送下棋信息 * */const dealBackgammonMessage = ( socketId, data ) => {	switch ( data.type ) {		case "backgammon-point":		case "backgammon-refresh":		case "backgammon-first-move":			sendRoomMessage( socketId, data );			break;		case "backgammon-get-refresh":			dealRefresh( socketId, data );			break;	}}/** * 发送聊天信息 * */const dealChatMessage = ( socketId, data ) => {	switch ( data.type ) {		case "chat-msg":			sendRoomMessage( socketId, data )	}}/** * 通用发送房间消息 * */const sendRoomMessage = ( socketId, data, type ) => {	const { roomId } = data.data;	const room = rooms[ roomId ];	for ( let i = 0; i < room.length; i++ ) {		let rivalSocketId = room[ i ];		if ( type !== void 0 ) {			delete data.data.roomId;			socketIdDictionary[ rivalSocketId ].send( JSON.stringify( data ) )		} else {			if ( socketId !== rivalSocketId ) {				delete data.data.roomId;				socketIdDictionary[ rivalSocketId ].send( JSON.stringify( data ) )			}		}	}}/** * 处理重新开始 * */const dealRefresh = ( id, data ) => {	const { roomId, status } = data.data;	const room = rooms[ roomId ] ;	let index = null;	let res = false;	for ( let i = 0; i < room.length; i++ ) {		let roomUserInfo = Object.assign( {}, getRoomUserInfo( room[ i ] ) );		const { type, refresh } = roomUserInfo;		console.log( id, room[ i ], type )		if ( id !== room[ i ] && type === 'rival' ) {			if ( refresh === void 0 || !refresh ) {				socketIdDictionary[ room[ i ] ].send( JSON.stringify( {					type: "backgammon-get-refresh"				} ) )			} else {				res = true;				delete roomUserInfo.refresh;				socketIdDictionary[ room[ i ] ].send( JSON.stringify( {					type: "backgammon-refresh",					data: {						status					}				} ) )			}		} else {			index = i;			roomUserInfo.refresh = true;		}		addRoomInfo( room[ i ], roomId, roomUserInfo );	}	if ( res ) delete room[ index ].refresh;}